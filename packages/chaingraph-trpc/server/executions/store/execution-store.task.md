# Execution store task

1. Create an executions postgres store with the interface: @packages/chaingraph-trpc/server/executions/store/execution-store.ts
2. Create executions logs store for the events generated by the execution engine: @packages/chaingraph-types/src/flow/execution-events.ts
3. tRPC method to subscribe execution logs from the specified event index number.  reference to:
   - @packages/chaingraph-trpc/server/executions/routes/execution-router.ts:subscribeToEvents



---

# Revised Implementation Plan for Execution Store

1. Database Schema Design

Executions Table (chaingraph_executions)
- id (text, primary key) - Execution ID
- flow_id (text, not null) - Reference to the flow being executed
- owner_id (text) - User who initiated the execution
- parent_execution_id (text) - For child executions
- status (text) - Current execution status
- started_at (timestamp) - When execution started
- completed_at (timestamp) - When execution completed/failed
- created_at (timestamp) - Record creation time
- updated_at (timestamp) - Record update time

Execution Events Table (chaingraph_execution_events)
- execution_id (text, not null) - Foreign key to executions
- event_index (integer, not null) - Event sequence number within execution
- event_type (text, not null) - ExecutionEventEnum value
- timestamp (timestamp, not null) - When event occurred
- data (jsonb, not null) - Event-specific data
- Primary Key: (execution_id, event_index) composite key

Indexes:
- (execution_id, event_index) - Primary key index
- (execution_id, timestamp) - For time-based queries
- (execution_id, event_type) - For filtering by event type
- (owner_id, created_at) - For listing user's executions
- (parent_execution_id) - For recursive queries to build execution trees
- (flow_id) - For finding executions by flow

2. PostgreSQL Store Implementation Structure

File Structure:
packages/chaingraph-trpc/server/executions/store/postgres/
├── schema.ts           # Drizzle ORM table definitions
├── execution-store.ts  # PostgreSQL implementation of IExecutionStore
├── event-store.ts      # Event storage and retrieval logic
└── index.ts           # Exports

3. Hybrid Storage Strategy

In-Memory + PostgreSQL Approach:
- In-memory store remains the primary store for active executions
- PostgreSQL store runs in parallel for persistence
- All operations write to both stores simultaneously
- Read operations use in-memory store for active executions
- PostgreSQL provides durability and history

Implementation Pattern:
class HybridExecutionStore implements IExecutionStore {
constructor(
private memoryStore: InMemoryExecutionStore,
private postgresStore: PostgresExecutionStore
) {}

    async create(instance: ExecutionInstance): Promise<void> {
      // Write to both stores in parallel
      await Promise.all([
        this.memoryStore.create(instance),
        this.postgresStore.create(instance)
      ])
    }

    async get(id: string): Promise<ExecutionInstance | null> {
      // Try memory first, fallback to PostgreSQL
      return await this.memoryStore.get(id)
        || await this.postgresStore.get(id)
    }
}

4. Event Storage Implementation

Event Store Features:
- Batch writing for performance (buffer up to 50 events or 100ms)
- Atomic event_index assignment within transactions
- Support for event replay from any index
- Efficient retrieval with pagination

Key Methods:
- storeEvents(executionId: string, events: ExecutionEvent[]) - Batch write
- getEvents(executionId: string, fromIndex?: number, limit?: number) - Retrieve with pagination
- getEventsByType(executionId: string, eventType: string) - Filtered retrieval

5. Enhanced tRPC Subscription

Modified subscribeToEvents Implementation:
1. Validate execution exists
2. If lastEventId provided:
   - Query PostgreSQL for events after lastEventId
   - Stream historical events to client
3. Subscribe to live EventQueue
4. Continue streaming new events as they occur
5. Handle disconnection/reconnection gracefully

6. Recursive Query Support

Execution Tree Queries:
- Use PostgreSQL recursive CTEs to retrieve execution hierarchies
- Support queries like:
    - Get all child executions of a parent
    - Get the full execution tree from root
    - Get execution depth/path

Example query structure:
WITH RECURSIVE execution_tree AS (
SELECT * FROM chaingraph_executions WHERE id = $1
UNION ALL
SELECT e.* FROM chaingraph_executions e
JOIN execution_tree et ON e.parent_execution_id = et.id
)
SELECT * FROM execution_tree;

7. Migration Strategy

Database Migration:
1. Create migration file for new tables and indexes
2. Use existing Drizzle migration system
3. No data migration needed (starting fresh)

Code Migration:
1. Implement PostgreSQL stores alongside existing code
2. Create HybridExecutionStore wrapper
3. Update context initialization to use hybrid store
4. No changes to existing API contracts

8. Configuration

Environment Variables:
- Use existing DATABASE_URL for connection
- Add EXECUTION_EVENT_BATCH_SIZE (default: 50)
- Add EXECUTION_EVENT_BATCH_TIMEOUT (default: 100ms)

9. Implementation Order

1. Phase 1: Database Schema
   - Create migration file with tables and indexes
   - Run migration to create database structure
2. Phase 2: PostgreSQL Stores
   - Implement PostgresExecutionStore
   - Implement EventStore for batch operations
   - Create HybridExecutionStore wrapper
3. Phase 3: Integration
   - Update ExecutionService to persist events
   - Modify context initialization
   - Keep existing functionality intact
4. Phase 4: Enhanced Subscriptions
   - Update subscribeToEvents to use persisted events
   - Implement event replay from database
   - Test reconnection scenarios

This approach ensures:
- Zero downtime during implementation
- No breaking changes to existing code
- Gradual migration path
- Full backward compatibility
- Performance through hybrid approach
